https://github.com/libjpeg-turbo/libjpeg-turbo/commit/2a9e3bd7430cfda1bc812d139e0609c6aca0b884

diff --git a/java/TJBench.java b/java/TJBench.java
index 5185d65..fd626af 100644
--- a/java/TJBench.java
+++ b/java/TJBench.java
@@ -96,6 +96,8 @@ class TJBench {
     int rindex = TJ.getRedOffset(pixelFormat);
     int gindex = TJ.getGreenOffset(pixelFormat);
     int bindex = TJ.getBlueOffset(pixelFormat);
+    if ((long)w[0] * (long)h[0] * (long)ps > (long)Integer.MAX_VALUE)
+      throw new Exception("Image is too large");
     byte[] dstBuf = new byte[w[0] * h[0] * ps];
     int pixels = w[0] * h[0], dstPtr = 0, rgbPtr = 0;
     while (pixels-- > 0) {
@@ -147,9 +149,11 @@ class TJBench {
 
     tjd = new TJDecompressor();
 
-    if (dstBuf == null)
+    if (dstBuf == null) {
+      if ((long)pitch * (long)scaledh > (long)Integer.MAX_VALUE)
+        throw new Exception("Image is too large");
       dstBuf = new byte[pitch * scaledh];
-
+    }
     /* Set the destination buffer to gray so we know whether the decompressor
        attempted to write to it */
     Arrays.fill(dstBuf, (byte)127);
@@ -287,6 +291,8 @@ class TJBench {
     String pfStr = pixFormatStr[pf];
     YUVImage yuvImage = null;
 
+    if ((long)pitch * (long)h > (long)Integer.MAX_VALUE)
+      throw new Exception("Image is too large");
     tmpBuf = new byte[pitch * h];
 
     if (quiet == 0)
@@ -435,6 +441,8 @@ class TJBench {
     int ps = TJ.getPixelSize(pf), tile;
 
     FileInputStream fis = new FileInputStream(fileName);
+    if (fis.getChannel().size() > (long)Integer.MAX_VALUE)
+      throw new Exception("Image is too large");
     int srcSize = (int)fis.getChannel().size();
     srcBuf = new byte[srcSize];
     fis.read(srcBuf, 0, srcSize);
diff --git a/tjbench.c b/tjbench.c
index 21b297c..625feae 100644
--- a/tjbench.c
+++ b/tjbench.c
@@ -32,6 +32,7 @@
 #include <ctype.h>
 #include <math.h>
 #include <errno.h>
+#include <limits.h>
 #include <cdjpeg.h>
 #include "./bmp.h"
 #include "./tjutil.h"
@@ -127,7 +128,10 @@ int decomp(unsigned char *srcbuf, unsigned char **jpegbuf,
 
 	if(dstbuf==NULL)
 	{
-		if((dstbuf=(unsigned char *)malloc(pitch*scaledh))==NULL)
+       		if ((unsigned long long)pitch * (unsigned long long)scaledh >
+        	(unsigned long long)((size_t)-1))
+     			_throw("allocating destination buffer", "Image is too large");
+    		if ((dstbuf = (unsigned char *)malloc((size_t)pitch * scaledh)) == NULL)
 			_throwunix("allocating destination buffer");
 		dstbufalloc=1;
 	}
@@ -139,7 +143,10 @@ int decomp(unsigned char *srcbuf, unsigned char **jpegbuf,
 	{
 		int width=dotile? tilew:scaledw;
 		int height=dotile? tileh:scaledh;
-		int yuvsize=tjBufSizeYUV2(width, yuvpad, height, subsamp);
+    		unsigned long yuvsize = tjBufSizeYUV2(width, yuvpad, height, subsamp);
+ 
+    		if (yuvsize == (unsigned long)-1)
+		      _throwtj("allocating YUV buffer");
 		if((yuvbuf=(unsigned char *)malloc(yuvsize))==NULL)
 			_throwunix("allocating YUV buffer");
 		memset(yuvbuf, 127, yuvsize);
@@ -242,14 +249,14 @@ int decomp(unsigned char *srcbuf, unsigned char **jpegbuf,
 		if(!quiet) printf("Compression error written to %s.\n", tempstr);
 		if(subsamp==TJ_GRAYSCALE)
 		{
-			int index, index2;
+			unsigned long index, index2;
 			for(row=0, index=0; row<h; row++, index+=pitch)
 			{
 				for(col=0, index2=index; col<w; col++, index2+=ps)
 				{
-					int rindex=index2+tjRedOffset[pf];
-					int gindex=index2+tjGreenOffset[pf];
-					int bindex=index2+tjBlueOffset[pf];
+					unsigned long rindex=index2+tjRedOffset[pf];
+					unsigned long gindex=index2+tjGreenOffset[pf];
+					unsigned long bindex=index2+tjBlueOffset[pf];
 					int y=(int)((double)srcbuf[rindex]*0.299
 						+ (double)srcbuf[gindex]*0.587
 						+ (double)srcbuf[bindex]*0.114 + 0.5);
@@ -290,13 +297,16 @@ int fullTest(unsigned char *srcbuf, int w, int h, int subsamp, int jpegqual,
 	unsigned char **jpegbuf=NULL, *yuvbuf=NULL, *tmpbuf=NULL, *srcptr, *srcptr2;
 	double start, elapsed, elapsedEncode;
 	int totaljpegsize=0, row, col, i, tilew=w, tileh=h, retval=0;
-	int iter, yuvsize=0;
-	unsigned long *jpegsize=NULL;
+	int iter;
+	unsigned long *jpegsize=NULL, yuvsize = 0;
 	int ps=tjPixelSize[pf];
 	int ntilesw=1, ntilesh=1, pitch=w*ps;
 	const char *pfStr=pixFormatStr[pf];
 
-	if((tmpbuf=(unsigned char *)malloc(pitch*h)) == NULL)
+  	if ((unsigned long long)pitch * (unsigned long long)h >
+      		(unsigned long long)((size_t)-1))
+    		_throw("allocating temporary image buffer", "Image is too large");
+  	if ((tmpbuf = (unsigned char *)malloc((size_t)pitch * h)) == NULL)
 		_throwunix("allocating temporary image buffer");
 
 	if(!quiet)
@@ -339,6 +349,8 @@ int fullTest(unsigned char *srcbuf, int w, int h, int subsamp, int jpegqual,
 		if(doyuv)
 		{
 			yuvsize=tjBufSizeYUV2(tilew, yuvpad, tileh, subsamp);
+      			if (yuvsize == (unsigned long)-1)
+			        _throwtj("allocating YUV buffer");
 			if((yuvbuf=(unsigned char *)malloc(yuvsize))==NULL)
 				_throwunix("allocating YUV buffer");
 			memset(yuvbuf, 127, yuvsize);
@@ -418,7 +430,7 @@ int fullTest(unsigned char *srcbuf, int w, int h, int subsamp, int jpegqual,
 			{
 				printf("Encode YUV    --> Frame rate:         %f fps\n",
 					(double)iter/elapsedEncode);
-				printf("                  Output image size:  %d bytes\n", yuvsize);
+        			printf("                  Output image size:  %lu bytes\n", yuvsize);
 				printf("                  Compression ratio:  %f:1\n",
 					(double)(w*h*ps)/(double)yuvsize);
 				printf("                  Throughput:         %f Megapixels/sec\n",
@@ -559,9 +571,12 @@ int decompTest(char *filename)
 			_throwunix("allocating JPEG size array");
 		memset(jpegsize, 0, sizeof(unsigned long)*ntilesw*ntilesh);
 
-		if((flags&TJFLAG_NOREALLOC)!=0 || !dotile)
+    			if ((flags & TJFLAG_NOREALLOC) != 0 &&
+        			(dotile || xformop != TJXOP_NONE || xformopt != 0 || customFilter))
 			for(i=0; i<ntilesw*ntilesh; i++)
 			{
+        			if (tjBufSize(tilew, tileh, subsamp) > (unsigned long)INT_MAX)
+          				_throw("getting buffer size", "Image is too large");
 				if((jpegbuf[i]=(unsigned char *)tjAlloc(tjBufSize(tilew, tileh,
 					subsamp)))==NULL)
 					_throwunix("allocating JPEG tiles");
@@ -683,9 +698,13 @@ int decompTest(char *filename)
 		{
 			if(quiet==1) printf("N/A     N/A     ");
 			jpegsize[0]=srcsize;
-			free(jpegbuf[0]);
-			jpegbuf[0]=srcbuf;
-			srcbuf=NULL;
+			if (jpegbuf[0]) {
+				tjFree(jpegbuf[0]);
+				jpegbuf[0] = NULL;
+			} else {
+				jpegbuf[0]=srcbuf;
+				srcbuf=NULL;
+			}
 		}
 
 		if(w==tilew) _tilew=_w;
@@ -700,7 +719,8 @@ int decompTest(char *filename)
 
 		for(i=0; i<ntilesw*ntilesh; i++)
 		{
-			tjFree(jpegbuf[i]);  jpegbuf[i]=NULL;
+      			if(jpegbuf[i]) tjFree(jpegbuf[i]);
+      			jpegbuf[i] = NULL;
 		}
 		free(jpegbuf);  jpegbuf=NULL;
 		if(jpegsize) {free(jpegsize);  jpegsize=NULL;}
diff --git a/turbojpeg.c b/turbojpeg.c
index c9bc619..936e1c0 100644
--- a/turbojpeg.c
+++ b/turbojpeg.c
@@ -622,7 +622,7 @@ DLLEXPORT tjhandle DLLCALL tjInitCompress(void)
 DLLEXPORT unsigned long DLLCALL tjBufSize(int width, int height,
 	int jpegSubsamp)
 {
-	unsigned long retval=0;  int mcuw, mcuh, chromasf;
+	unsigned long long retval=0;  int mcuw, mcuh, chromasf;
 	if(width<1 || height<1 || jpegSubsamp<0 || jpegSubsamp>=NUMSUBOPT)
 		_throw("tjBufSize(): Invalid argument");
 
@@ -632,32 +632,37 @@ DLLEXPORT unsigned long DLLCALL tjBufSize(int width, int height,
 	mcuw=tjMCUWidth[jpegSubsamp];
 	mcuh=tjMCUHeight[jpegSubsamp];
 	chromasf=jpegSubsamp==TJSAMP_GRAY? 0: 4*64/(mcuw*mcuh);
-	retval=PAD(width, mcuw) * PAD(height, mcuh) * (2 + chromasf) + 2048;
+	retval=PAD(width, mcuw) * PAD(height, mcuh) * (2ULL + chromasf) + 2048ULL;
+  	if (retval > (unsigned long long)((unsigned long)-1))
+    		_throw("tjBufSize(): Image is too large");
 
 	bailout:
-	return retval;
+	return (unsigned long)retval;
 }
 
 DLLEXPORT unsigned long DLLCALL TJBUFSIZE(int width, int height)
 {
-	unsigned long retval=0;
+	unsigned long long retval=0;
 	if(width<1 || height<1)
 		_throw("TJBUFSIZE(): Invalid argument");
 
 	/* This allows for rare corner cases in which a JPEG image can actually be
 	   larger than the uncompressed input (we wouldn't mention it if it hadn't
 	   happened before.) */
-	retval=PAD(width, 16) * PAD(height, 16) * 6 + 2048;
+	retval=PAD(width, 16) * PAD(height, 16) * 6ULL + 2048ULL;
+	if (retval > (unsigned long long)((unsigned long)-1))
+		_throw("TJBUFSIZE(): Image is too large");
 
 	bailout:
-	return retval;
+	return (unsigned long)retval;
 }
 
 
 DLLEXPORT unsigned long DLLCALL tjBufSizeYUV2(int width, int pad, int height,
 	int subsamp)
 {
-	int retval=0, nc, i;
+	unsigned long long retval=0;
+	int nc, i;
 
 	if(subsamp<0 || subsamp>=NUMSUBOPT)
 		_throw("tjBufSizeYUV2(): Invalid argument");
@@ -669,11 +674,13 @@ DLLEXPORT unsigned long DLLCALL tjBufSizeYUV2(int width, int pad, int height,
 		int stride=PAD(pw, pad);
 		int ph=tjPlaneHeight(i, height, subsamp);
 		if(pw<0 || ph<0) return -1;
-		else retval+=stride*ph;
+		else retval+= (unsigned long long)stride*ph;
 	}
+  	if (retval > (unsigned long long)((unsigned long)-1))
+    		_throw("tjBufSizeYUV2(): Image is too large");
 
 	bailout:
-	return retval;
+	return (unsigned long)retval;
 }
 
 DLLEXPORT unsigned long DLLCALL tjBufSizeYUV(int width, int height,
@@ -734,7 +741,7 @@ DLLEXPORT int tjPlaneHeight(int componentID, int height, int subsamp)
 DLLEXPORT unsigned long DLLCALL tjPlaneSizeYUV(int componentID, int width,
 	int stride, int height, int subsamp)
 {
-	unsigned long retval=0;
+	unsigned long long retval=0;
 	int pw, ph;
 
 	if(width<1 || height<1 || subsamp<0 || subsamp>=NUMSUBOPT)
@@ -747,10 +754,12 @@ DLLEXPORT unsigned long DLLCALL tjPlaneSizeYUV(int componentID, int width,
 	if(stride==0) stride=pw;
 	else stride=abs(stride);
 
-	retval=stride*(ph-1)+pw;
+	retval=(unsigned long long)stride*(ph-1)+pw;
+  	if (retval > (unsigned long long)((unsigned long)-1))
+    		_throw("tjPlaneSizeYUV(): Image is too large");
 
 	bailout:
-	return retval;
+	return (unsigned long)retval;
 }
 
 
@@ -813,8 +822,8 @@ DLLEXPORT int DLLCALL tjCompress2(tjhandle handle, const unsigned char *srcBuf,
 	for(i=0; i<height; i++)
 	{
 		if(flags&TJFLAG_BOTTOMUP)
-			row_pointer[i]=(JSAMPROW)&srcBuf[(height-i-1)*pitch];
-		else row_pointer[i]=(JSAMPROW)&srcBuf[i*pitch];
+			row_pointer[i]=(JSAMPROW)&srcBuf[(height-i-1)*(size_t)pitch];
+		else row_pointer[i]=(JSAMPROW)&srcBuf[i*(size_t)pitch];
 	}
 	while(cinfo->next_scanline<cinfo->image_height)
 	{
@@ -940,8 +949,8 @@ DLLEXPORT int DLLCALL tjEncodeYUVPlanes(tjhandle handle,
 	for(i=0; i<height; i++)
 	{
 		if(flags&TJFLAG_BOTTOMUP)
-			row_pointer[i]=(JSAMPROW)&srcBuf[(height-i-1)*pitch];
-		else row_pointer[i]=(JSAMPROW)&srcBuf[i*pitch];
+			row_pointer[i]=(JSAMPROW)&srcBuf[(height-i-1)*(size_t)pitch];
+		else row_pointer[i]=(JSAMPROW)&srcBuf[i*(size_t)pitch];
 	}
 	if(height<ph0)
 		for(i=height; i<ph0; i++) row_pointer[i]=row_pointer[height-1];
@@ -1462,8 +1471,8 @@ DLLEXPORT int DLLCALL tjDecompress2(tjhandle handle,
 	for(i=0; i<(int)dinfo->output_height; i++)
 	{
 		if(flags&TJFLAG_BOTTOMUP)
-			row_pointer[i]=&dstBuf[(dinfo->output_height-i-1)*pitch];
-		else row_pointer[i]=&dstBuf[i*pitch];
+			row_pointer[i]=&dstBuf[(dinfo->output_height-i-1)*(size_t)pitch];
+		else row_pointer[i]=&dstBuf[i*(size_t)pitch];
 	}
 	while(dinfo->output_scanline<dinfo->output_height)
 	{
@@ -1648,8 +1657,8 @@ DLLEXPORT int DLLCALL tjDecodeYUVPlanes(tjhandle handle,
 		_throw("tjDecodeYUVPlanes(): Memory allocation failure");
 	for(i=0; i<height; i++)
 	{
-		if(flags&TJFLAG_BOTTOMUP) row_pointer[i]=&dstBuf[(height-i-1)*pitch];
-		else row_pointer[i]=&dstBuf[i*pitch];
+		if(flags&TJFLAG_BOTTOMUP) row_pointer[i]=&dstBuf[(height-i-1)*(size_t)pitch];
+		else row_pointer[i]=&dstBuf[i*(size_t)pitch];
 	}
 	if(height<ph0)
 		for(i=height; i<ph0; i++) row_pointer[i]=row_pointer[height-1];
